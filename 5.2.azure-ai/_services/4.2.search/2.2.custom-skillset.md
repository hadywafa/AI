# üß† Custom Skills in Azure AI Search

> **Custom Skills** are used when built-in skills just aren't enough ‚Äî they allow you to call **your own Web APIs** to perform any logic, ML inference, data transformation, or extraction.

---

## üß™ Why Use Custom Skills?

Use custom skills when you need to:

‚úÖ **Enhance Document Processing**

- E.g., extract structured data using Azure Document Intelligence

‚úÖ **Use Machine Learning Models**

- Call Azure ML or HuggingFace models for intent classification, summarization, etc.

‚úÖ **Implement Custom Logic**

- Extract domain-specific values like invoice numbers, employee IDs, or code references

---

<div style="text-align: center;">
    <img src="images/custom-skills-use-cases.png" alt="custom-skills-use-cases" style="border-radius: 10px; width: 60%;">
</div>

---

## ‚öôÔ∏è How Custom Skills Work

> Custom skills are implemented as **Web APIs** and plugged into your **Skillset** pipeline.

---

<div style="text-align: center;">
    <img src="images/how-custom-skills-works.png" alt="how-custom-skills-works" style="border-radius: 10px; width: 60%;">
</div>

---

Your API is called by Azure Search, processes a batch of documents, and returns the enriched fields.

- You can use **Azure Functions**, **Flask apps**, or even **Docker APIs**
- Secured with **AAD**, **OAuth2**, or left public for testing

---

## üì• Custom Skill Interface ‚Äì Input Schema

Each batch Azure sends to your API looks like this:

```json
{
  "values": [
    {
      "recordId": "<unique-identifier>",
      "data": {
        "<input1_name>": "<value1>",
        "<input2_name>": "<value2>"
      }
    },
    {
      "recordId": "<unique-identifier>",
      "data": {
        "<input1_name>": "<value1>",
        "<input2_name>": "<value2>"
      }
    }
  ]
}
```

‚úÖ Each item has:

- `"recordId"`: Unique ID per document (you must preserve this in output)
- `"data"`: The fields passed to your API as input

---

## üì§ Custom Skill Interface ‚Äì Output Schema

You return a matching array with processed values:

```json
{
  "values": [
    {
      "recordId": "<unique_identifier_from_input>",
      "data": {
        "<output1_name>": "<value1>",
        "<output2_name>": "<value2>"
      },
      "errors": [],
      "warnings": []
    },
    {
      "recordId": "<unique_identifier_from_input>",
      "data": {
        "<output1_name>": "<value1>",
        "<output2_name>": "<value2>"
      },
      "errors": [],
      "warnings": []
    }
  ]
}
```

‚úÖ You must:

- Preserve the `recordId`
- Put the result inside `data`
- Return optional `errors` and `warnings` for diagnostics

---

## üß± Steps to Add a Custom Skill

<div style="text-align: center;">
    <img src="images/custom-skill-implementation.png" style="border-radius: 10px; width: 90%;" alt="custom-skill-implementation">
</div>

---

### üîπ 1Ô∏è‚É£ Define the Web API

- Must support POST
- JSON in, JSON out
- Optionally secured (AAD, OAuth2)
- Accept `application/json`

---

### üîπ 2Ô∏è‚É£ Determine Context (Where it Applies)

- Use `context` to tell Azure where to apply (e.g., `/document`)
- Can loop over arrays (e.g., `/document/images/*`)

---

### üîπ 3Ô∏è‚É£ Map Input Fields

- Use `"inputs"` to map input names to JSON paths
- Example:

  ```json
  { "name": "text", "source": "/document/content" }
  ```

---

### üîπ 4Ô∏è‚É£ Define Output Fields

- Azure will store the output inside the enriched document
- You define both `"name"` and `"targetName"`

---

## üß™ JSON Example of a Custom Skill in a Skillset

```json
{
  "skills": [
    {
      "@odata.type": "#Microsoft.Skills.Custom.WebApiSkill",
      "description": "Extract employee ID from text",
      "uri": "https://your-function.azurewebsites.net/api/extract-employee-id",
      "httpHeaders": {
        "x-api-key": "your-api-key"
      },
      "context": "/document",
      "inputs": [{ "name": "text", "source": "/document/content" }],
      "outputs": [{ "name": "employeeId", "targetName": "employee_id" }]
    }
  ]
}
```

---

## üß™ Full Use Case Example: Extracting Employee ID

### üéØ Goal: Extract `EMP-xxxxx` from unstructured text documents

#### üì• Input sent by Azure to your Web API:

```json
{
  "values": [
    {
      "recordId": "1",
      "data": {
        "text": "Resume content: John Doe, EMP-98765, Software Engineer"
      }
    }
  ]
}
```

#### ‚öôÔ∏è Your API parses text using regex:

```python
import re
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route("/", methods=["POST"])
def skill():
    items = request.json["values"]
    results = []

    for item in items:
        text = item["data"].get("text", "")
        match = re.search(r"EMP-\d+", text)
        emp_id = match.group(0) if match else None

        results.append({
            "recordId": item["recordId"],
            "data": {
                "employeeId": emp_id
            },
            "errors": [],
            "warnings": []
        })

    return jsonify({"values": results})
```

#### üì§ Output returned to Azure AI Search:

```json
{
  "values": [
    {
      "recordId": "1",
      "data": {
        "employeeId": "EMP-98765"
      },
      "errors": [],
      "warnings": []
    }
  ]
}
```

---

## ‚úÖ Summary: Why You‚Äôd Use a Custom Skill

| Reason                       | Examples                                                 |
| ---------------------------- | -------------------------------------------------------- |
| Built-in skill doesn‚Äôt exist | Extract Invoice #, Employee ID, custom legal clause      |
| Need external ML             | Use Azure ML/LLM to generate embeddings, classifications |
| Need logic/validation        | Normalize values, match against lookup lists, etc.       |
